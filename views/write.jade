extends layout

block content
  script(src='/javascripts/editor.js')
  script(src='/javascripts/marked.js')
  script(src='/javascripts/color-thief.js')
  link(rel='stylesheet', href='/stylesheets/editor.css')
  link(rel='stylesheet', href='/stylesheets/yue.css')
  style(type="text/css").
    .night, .night code, .night input {
      background-color: white;
      color: #333;
    }
  button#main-menu-button.menu-toggle-button
    span Menu
    button#save-button Save
  nav#cbp-spmenu-right.cbp-spmenu.cbp-spmenu-vertical.cbp-spmenu-right
    h3 POSTS
    span#post-menu-items
      if unpublishedPosts
        for up in unpublishedPosts
          a.menu-post-link(data-post-id="#{up._id}", onclick="displayPost(this)") #{up.title}
    h3
      a(href="/") HOME
  #post-editor.pure-g-r(data-post-id="#{post ? post._id : ''}")
    .pure-u-1
      .editor-wrapper
        input#post-title-editor.title(type='text', placeholder='Title', value="#{post ? post.title : ''}")
        textarea#editor(placeholder="Body here ....") !{post ? post.markdown : ''}
        input#post-image(type='text', placeholder='http://image-url.jpg', value="#{post.image ? post.image : ''}")
        span#post-colors
          if post
            for color in post.colors 
              span(style="display:inline-block;height:10px;width:30px;background-color:#{color.hex ? color.hex : 'rgb('+[color.red,color.green,color.blue].join(',')+')'};")

  script.
    var editor = new Editor(),
      socket;
    editor.render();
    window.onload = function() {
        socket = io.connect(window.location.hostname);
        socket.on('savedPost', function(data) {
          console.log(data.post);
          var done = false;
          if(data.post.published == false){
            for(i=0;i<unPubs.length;i++){
              if(unPubs[i]._id == data.post._id){
                unPubs[i] = data.post;
                done = true;
                updateList(unPubs);
                console.log('extant unpublished');
              }
            }
            if(done == false){
              unPubs.push(data.post);
              updateList(unPubs);
              console.log('new unpublished');
            }
          }else{
            alert('published');
              for(i=0;i<unPubs.length;i++){
                  if(data.post._id == unPubs[i]._id){
                      unPubs.splice(i, 1);
                  }
              }
              updateList(unPubs);
              console.log('published');
          }
        });
        saveButton.onclick = function(){
          saveCurrent();
        };
    };
    function retrieveColors (parentEl) {
      var elements = parentEl.children,
        i = 0,
        length = elements.length,
        arr = [];
      for (; i < length; i++) {
        arr.push({
          red: parseInt(elements[i].dataset.red, 10),
          green: parseInt(elements[i].dataset.green, 10),
          blue: parseInt(elements[i].dataset.blue, 10),
          hex: elements[i].dataset.hex || ''
        });
      }
      return arr;
    }
    var saveCurrent = function(){
      var postEditor = document.getElementById('post-editor'),
          postID = postEditor.dataset.postId,
          title = document.getElementById('post-title-editor').value,
          body = editor.codemirror.getValue(),
          imageUrl = document.getElementById('post-image').value,
          colors = retrieveColors(document.getElementById('post-colors'));
      if(body && title){
        var r = confirm("Publish this?");
        if(postID){
          socket.emit('updatePost', {
            markdown: body,
            title: title,
            _id: postID,
            published: r,
            image: imageUrl,
            colors: colors,
            time: (new Date)
          });
        }else{
          socket.emit('createPost', {
            markdown: body,
            title: title,
            published: r,
            image: imageUrl,
            colors: colors,
            time: (new Date)
          });
        }
      }else{
        alert('need both title and body!');
      }
    };
    var unPubs = !{JSON.stringify(unpublishedPosts) || '[]'},
      saveButton = document.getElementById('save-button'),
      displayPost = function(elem){
        for(i=0;i<unPubs.length;i++){
          if(unPubs[i]._id == elem.dataset.postId){
            document.getElementById('post-editor').dataset.postId = elem.dataset.postId;
            document.getElementById('post-title-editor').value = unPubs[i].title;
            document.getElementById('post-image').value = unPubs[i].image || '';
            document.getElementById('post-colors').innerHTML = null;
            editor.codemirror.setValue(unPubs[i].markdown);
          }
        }
      },
      listenToMenuPosts = function(){
        var menuPosts = document.getElementsByClassName('menu-post-link');
        for(i=0;i<menuPosts.length;i++){
          menuPosts[i].onclick = function(){
            displayPost(this);
          }
        }
      },
      updateList = function(unPubs){
        var menu = document.getElementById('post-menu-items');
        menu.innerHTML = '';
        for(i=0;i<unPubs.length;i++){
          menu.appendChild(
            create('a',{
              textContent: unPubs[i].title,
              className: 'menu-post-link',
              dataset:{
                postId: unPubs[i]._id
              }
            })
          );
        }
        listenToMenuPosts();
      };
    listenToMenuPosts();
    // dnd interface and loading
    (function initializeDnd(window, document) {
      function handleDragOver(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
        document.body.style.border = '10px solid #5E5BD6';
      }
      function loadColors(image) {
        var colorThief = new ColorThief(),
          otherColors = colorThief.getPalette(image, 6),
          output = document.getElementById('post-colors'),
          i = 0,
          length = otherColors.length;
        output.innerHTML = null;
        for (; i <  length; i++) {
          output.appendChild(create('span', {
            style: {
              width: '30px',
              height:'10px',
              display: 'inline-block',
              background: 'rgb('+[otherColors[i][0].toString(), otherColors[i][1].toString(), otherColors[i][2].toString()].join(',')+')'
            },
            dataset: {
              red: otherColors[i][0],
              green: otherColors[i][1],
              blue: otherColors[i][2]
            }
          }));
        }
      }
      function handleImageDrop(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        document.body.style.border = 'none';
        function makeReaderLoadFxn() {
          return (function(theFile) {
            return function(e) {
              var result = e.target.result,
                editor = document.getElementById('post-editor');
              editor.appendChild(create('img', {
                src: result,
                id: 'dropped-image',
                onload: function() {loadColors(document.getElementById('dropped-image'));}
              }));
            };
          })(f);
        }
        if (window.File && window.FileReader && window.FileList && window.Blob) {
          var files = evt.dataTransfer.files,
              i = 0,
              f, reader;
          for (; i < files.length; i++) {
            f = files[i];
            if (!f.type.match(/image.*/)) {
              alert('You\'re gonna need to upload a valid image file!\nCurrently, you are uploading a file of type "'+f.type.toString()+'"');
              continue;
            }
            reader = new FileReader();
            reader.onload = makeReaderLoadFxn();
            reader.readAsDataURL(f);
          }
        } else {
          alert('Javascript File APIs are not fully supported in this here browser.\n That sucks.');
        }
      }
      var dropZone = document.getElementsByTagName('body')[0];
      dropZone.addEventListener('dragover', handleDragOver, false);
      dropZone.addEventListener('drop', handleImageDrop, false);
    })(this, this.document);
